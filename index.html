<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="utf-8">
    <title>Яндекс.Блог</title>
</head>
    <body>
        <header>Блог компании Яндекс.</header>
        <article>
            <h1>ЯНДЕКС.ПОЧТА: КАК МЫ ИЗМЕРЯЕМ СКОРОСТЬ ЗАГРУЗКИ И УЛУЧШАЕМ ЕЁ</h1>
            <p>Если ваш сайт медленно грузится, вы рискуете тем, что люди не оценят ни то,<br>
                какой он красивый, ни то, какой он удобный. Никому не понравится, когда все<br>
                тормозит. Мы регулярно добавляем в Яндекс.Почту новую функциональность,<br>
                иногда — исправляем ошибки, а это значит, у нас постоянно появляются новый код<br>
                и новая логика. Всё это напрямую влияет на скорость работы интерфейса.
            </p>

            <h2>Что мы измеряем</h2>
            <p>Этапы первой загрузки:</p>
            <ul>
                <li>подготовка;</li>
                <li>загрузка статики (HTTP-запрос и парсинг);</li>
                <li>исполнение модулей;</li>
                <li>инициализация базовых объектов;</li>
                <li>отрисовка.</li>
            </ul>
            <p>Этапы отрисовки любой страницы:</p>
            <ul>
                <li>подготовка;</li>
                <li>загрузка статики (HTTP-запрос и парсинг);</li>
                <li>исполнение модулей;</li>
                <li>инициализация базовых объектов;</li>
                <li>отрисовка.</li>
            </ul>

            <p>— <q>Ок, теперь у нас есть метрики, мы можем отправить их на сервер</q> - говорим мы<br>
                — <q>Что же дальше?</q> - вопрошаете вы<br>
                — <q>А давай построим график!</q> - отвечаем мы<br>
                — <q>А что будем считать?</q> - уточняете вы
            </p>
            <p>Как вы знаете, <dfn>медиана</dfn> – это серединное, а не среднее значение в выборке.<br>
                Если у нас имеются числа 1, 2, 2, 3, 8, 10, 20, то медиана – 3, а среднее – 6,5.<br>
                В общем случае медиана отлично показывает, сколько грузится средний пользователь.
            </p>

            <p>
                В случае ускорения или замедления медиана, конечно, изменится. Но она не может<br>
                рассказать, сколько пользователей ускорилось, а сколько замедлилось.
            </p>

            <p>
                <dfn>APDEX</dfn> – метрика, которая сразу говорит: хорошо или плохо. Метрика<br>
                работает очень просто. Мы выбираем временной интервал <var>[0; t]</var>, такой, что если<br>
                время показа страницы попало в него, то пользователь счастлив. Берем еще один<br>
                интервал, <var>(t; 4t]</var> (в четыре раза больше первого), и считаем, что если страница<br>
                показана за это время, то пользователь в целом удовлетворен скоростью работы,<br>
                но уже не настолько счастлив. И применяем формулу:
            </p>

            <p>
                <math xmlns="http://www.w3.org/1998/Math/MathML">
                <mrow>
                    <mfrac>
                        <mrow>
                            <mrow>кол-во счастливых пользователей</mrow>
                            <mo>+</mo>
                            <mrow>
                                    <mrow>(кол-во удовлетворенных</mrow>
                                    <mo>/</mo>
                                    <mrow>2)</mrow>
                            </mrow>
                        </mrow>
                        <mrow>кол-во всех</mrow>
                    </mfrac>
                </mrow>
                </math><br>
                Получается значение от нуля до единицы, которое, видимо, лучше всего показывает,<br>
                хорошо или плохо работает почта.
            </p>

            <h2>Как мы измеряем</h2>

            <p>
                Сейчас модуль обновления сам логирует все свои стадии, и можно легко понять<br>
                причину замедления: медленнее стал отвечать сервер либо слишком долго<br>
                выполняется JavaScript. Выглядит это примерно так:
            </p>

            <code>
                this.timings['look-ma-im-start'] = Date.now();<br>
                this.timings['look-ma-finish'] = Date.now();
            </code>

            <p>
                C помощью <code>Date.now()</code> мы получаем текущее время. Все тайминги собираются и при<br>
                отправке рассчитываются. На этапах разница между <q>end</q> и <q>start</q> не считается,<br>
                а все вычисления производятся в конце:
            </p>

            <p>
                <code>var totalTime = this.timings['look-ma-finish'] - this.timings['look-ma-im-start'];</code>
            </p>

            <p>И на сервер прилетают подобные записи:</p>

            <p><samp>serverResponse=50&domUpdate=60</samp></p>

            <h2>Как мы ускоряем</h2>

            <p>
                Чтобы снизить время загрузки почты при выходе новых версий,<br>
                мы уже делаем следующее:
            </p>

            <ul>
                <li>включаем gzip;</li>
                <li>выставляем заголовки кэширования;</li>
                <li>фризим CSS, JS, шаблоны и картинки;</li>
                <li>используем CDN;</li>
            </ul>

            <p>
                Мы подумали: <q>А что если хранить где-то старую версию файлов, а при выходе новой<br>
                передавать только diff между ней и той, которая сохранена у пользователя?</q><br>
                В браузере же останется просто наложить патч на клиенте.
            </p>

            <p>
                На самое деле эта идея не нова. Уже существуют стандарты для HTTP — например,<br>
                RFC 3229 <q>Delta encoding in HTTP</q> и <q>Google SDHC</q>, — но по разным причинам они<br>
                не получили должного распространения в браузерах и на серверах.
            </p>

            <p>
                Мы же решили сделать свой аналог на JS. Чтобы реализовать этот метод обновления,<br>
                начали искать реализации diff на JS. На популярных хостингах кода нашли<br>
                библиотеки:<br>
                <ul>
                    <li>VCDiff</li>
                    <li>google-diff-patch-match</li>
                </ul>
            </p>
            <p>Для окончательного выбора библиотеки нам нужно сравнить:</p>
            <table style="text-align: center" width="300px">
                <thead>
                    <tr>
                        <th>Библиотека</th>
                        <th>IE 9</th>
                        <th>Opera 12</th>
                    </tr>
                </thead>
                <tr colspan="2">
                    <td>vcdiff</td>
                    <td>8</td>
                    <td>5</td>
                </tr>
                    <td>google diff</td>
                    <td>1363</td>
                    <td>76</td>
            </table>
            <p>После того как мы определились с библиотекой для диффа, нужно определиться с тем,<br>
        где и как хранить статику на клиенте.</p>
            <p>Формат файла с патчами для проекта выглядит так:<br>
                <code>
                    <pre>
[
    {
        <q>k</q>: <q>jane.css</q>,
        <q>p</q>: [patch],
        <q>s</q>: 4554
    },
    {
        <q>k</q>: <q>jane.css</q>,
        <q>p</q>: [patch],
        <q>s</q>: 4554
    }
]
                    </pre>
                </code>
            </p>
            <p>
                То есть это обычный массив из объектов. Каждый объект — отдельный ресурс. У<br>
        каждого объекта есть три свойства. <dfn>k</dfn> — названия ключа в localStorage для этого<br>
        ресурса. <dfn>p</dfn> — патч для ресурса, который сгенерировал vcdiff. <dfn>s</dfn> — чексумма для<br>
        ресурса актуальной версии, чтобы потом можно было проверить правильность<br>
        наложения патча на клиенте. Чексумма вычисляется по <cite>алгоритму Флетчера</cite>.
            </p>
            <p>
                <dfn><cite>Алгоритм Бройдена — Флетчера — Гольдфарба — Шанно (BFGS)</cite></dfn><br>
        — итерационный метод численной оптимизации, предназначенный для<br>
        нахождения локального максимума/минимума нелинейного функционала<br>
        без ограничений.
            </p>
            <p>Почему именно алгоритм Флетчера, а не другие популярные алгоритмы вроде:<br>
                <dfn>CRC16/32</dfn> - алгоритм нахождения контрольной суммы, предназначенный для проверки<br>
                целостности данных<br>
                <dfn>md5</dfn> - 128-битный алгоритм хеширования. Предназначен для создания «отпечатков»<br>
                или дайджестов сообщения произвольной длины и последующей проверки<br>
                их подлинности.
            </p>
            <p>Потому что он быстрый, компактный и легок в реализации.</p>
            <h2>Итог</h2>
            <p>Фактически мы экономим <var>80-90%</var> трафика. Размер загружаемой статитки в байтах:</p>
            <table style="text-align: center" width="300px">
                <thead>
                    <tr>
                        <th>Релиз</th>
                        <th>С патчем</th>
                        <th>Без патча</th>
                    </tr>
                </thead>
                <tr>
                    <td>7.7.20</td>
                    <td>397</td>
                    <td>174 549</td>
                </tr>
                <tr>
                    <td>7.7.21</td>
                    <td>383</td>
                    <td>53 995</td>
                </tr>
                <tr>
                    <td>7.7.22</td>
                    <td>483</td>
                    <td>3 995</td>
                </tr>
            </table>
            <section>
                <h1>Комментарии (3):</h1>
                <article>
                    <dl>
                        <dt>- <cite>Mogaika</cite> (mogaika@yandex-team.ru) <time>30 ноября 2014 в 17:05</time></dt>
                        <dd><p>А можете привести сравнение, на сколько быстрее грузится lite версия?</p></dd>
                    </dl>
                </article>

                <article>
                    <dl>
                        <dt>- <cite>JIguse</cite> (mrawesome@yandex.ru) <time>29 ноября 2014 в 21:30</time></dt>
                        <dd><p>Спасибо за статью, познавательно. Здорово, что Яндекс делится некоторыми<br>
              подробностями о внутренней работе сервисов.</p></dd>
                    </dl>
                </article>

                <article>
                    <dl>
                        <dt>- <cite>Brister</cite> (brist89@yandex-team.ru) <time>24 ноября 2014 в 13:13</time></dt>
                        <dd><p>
                            <math xmlns="http://www.w3.org/1998/Math/MathML">
                            <mrow>
                                <mfrac>
                                    <mrow>
                                        <mrow>кол-во счастливых пользователей</mrow>
                                        <mo>+</mo>
                                        <mrow>
                                                <mrow>(кол-во удовлетворенных</mrow>
                                                <mo>/</mo>
                                                <mrow>2)</mrow>
                                        </mrow>
                                    </mrow>
                                    <mrow>кол-во всех</mrow>
                                </mfrac>
                            </mrow>
                            </math><br>
                            Получается значение от нуля до единицы, которое, видимо, лучше всего показывает,<br>
                            хорошо или плохо работает почта.<br>
                            <hr>
                            <ins>наверное все-таки от 0.5 до 1</ins></p>
                        </dd>
                    </dl>
                </article>
                <article>
                    <dl>
                        <dt>- <cite>alexeimois</cite> (test@yandex.ru) <time>22 ноября 2014 в 17:35</time></dt>
                        <dd><p>Мы измеряем скорость загрузки с помощью Яндекс.Метрики:<br>
                            <address>help.yandex.ru/metrika/reports/monitoring_timing.xml</address><p>
                        </dd>
                    </dl>
                </article>
            </section>
        </article>

        <footer>
            <p>© Яндекс, help@yandex.ru, Хохрякова, 10</p>
        </footer>

    </body>
</html>
